
#include <cstdlib>
#include <iostream>
#include <stack>
#include <queue>
 
using namespace std;
 
//二叉树定义 
typedef char ElementType;
 
typedef struct BiTreeNode
{
	ElementType data;
    struct BiTreeNode* lchild;
    struct BiTreeNode* rchild;
}BiTreeNode, *BiTree;
 
//递归的建立一棵二叉树 
//输入为二叉树的先序序列 
void createBiTree(BiTree &T)
{
	char data;
	data = getchar();
	if(data == '#')
	{
		T = NULL;
	}
	else
	{
		T = new BiTreeNode;
		T->data = data;
		createBiTree(T->lchild);
		createBiTree(T->rchild);
	}
}
 
//递归销毁一棵二叉树
void destroyBiTree(BiTree &T)
{
	if(T)
	{
		destroyBiTree(T->lchild);
		destroyBiTree(T->rchild);
		delete T;
		T = NULL;
	}
}
 
//二叉树的层次遍历，用到了队列 
void levelOrderTraverse(const BiTree& T)
{
	queue<BiTree> q;
	BiTree p = NULL;
	
	if(T)//若根结点非空，则入队列 
	{
		q.push(T);
	}
	while(!q.empty())//队列非空 
	{
		p = q.front();
		q.pop();
		cout<<p->data<<" ";
		if(p->lchild)//左孩子不空，入队列 
		{
			q.push(p->lchild);
		}
		if(p->rchild)//右孩子不空，入队列 
		{
			q.push(p->rchild);
		}
	} 
}
 
//二叉树的先序非递归遍历 
void iterativePreOrderTraverse(const BiTree& T)
{
	stack<BiTree> s;
	BiTree p = T;
	
	while(p || !s.empty())//p非空，或栈非空
	{
		if(p)
		{
			//输出根结点，根结点入栈，遍历左子树 
			cout<<p->data<<" ";
			s.push(p);
			p = p->lchild;
		}
		else
		{
			//根结点退栈，遍历右子树 
			p = s.top();
			s.pop();
			p = p->rchild;//转右孩子结点 
		}
	}
}
 
//二叉树的中序非递归遍历 
void iterativeInOrderTraverse(const BiTree& T)
{
	stack<BiTree> s;
	BiTree p = T;
	
	while(p || !s.empty())//p非空，或栈非空
	{
		if(p)
		{
			//根指针进栈 ，遍历左子树 
			s.push(p);	
			p = p->lchild;
		}
		else
		{
			//根指针退栈，访问根结点，遍历右子树 
			p = s.top();
			s.pop();
			cout<<p->data<<" ";
			p = p->rchild;
		}
	}
}
 
//二叉树的后序非递归遍历 
void iterativePostOrderTraverse(const BiTree& T)
{
	stack<pair<BiTree,bool> > s;
	BiTree p = T;
	
	while(p || !s.empty())  
	{
		if(p)
		{
			s.push(make_pair(p,false));//false表示根结点p的右子树未访问 
			p = p->lchild;
		}
		else
		{
			if(s.top().second == false)//根结点的右子树未访问 
			{
				s.top().second = true;//标志右子树为已访问 
				p = s.top().first->rchild;//遍历右子树 
			}
			else//右子树已访问 
			{
				cout<<s.top().first->data<<" "; //输出根结点值 
				s.pop();//根结点出栈 
			}
		}	
	}
}
 
//后序非递归遍历的另一个版本 
void anotherIterativePostOrderTraverse(const BiTree& T)
{
	stack<pair<BiTree,bool> > s;
	BiTree p = T;
	
	do
	{
		while(p)
		{
			s.push(make_pair(p,false));
			p = p->lchild;
		}
		
		while(!s.empty() && s.top().second == true)
		{
			cout<<s.top().first->data<<" ";
			s.pop();
		}
		
		if(!s.empty())
		{
			s.top().second = true;
			p = s.top().first->rchild;
		}
	}while(!s.empty());
}
 /*
int main(int argc, char *argv[])
{
	BiTree T = NULL;
	
	createBiTree(T);//递归建立二叉树 如输入AB#D##CE### 
//	createBiTreeWithGenList(T);//如输入A(B(,D),C(E))#
 
	cout<<"levelOrder: ";
	levelOrderTraverse(T);
	cout<<endl;
	
	cout<<"preOrder: "; //先序遍历 
//	preOrderTraverse(T);
	iterativePreOrderTraverse(T);
	cout<<endl;
	
	cout<<"inOrder: ";//中序遍历 
//	inOrderTraverse(T);
	iterativeInOrderTraverse(T);
	cout<<endl;
	
	cout<<"postOrder: ";//后序遍历 
//	postOrderTraverse(T);
//	iterativePostOrderTraverse(T);
	anotherIterativePostOrderTraverse(T);
	cout<<endl;
	
	destroyBiTree(T);//销毁二叉树，释放空间 
	
    system("PAUSE");
    return EXIT_SUCCESS;
	//https://blog.csdn.net/sysu_arui/article/details/7865873
}
*/
数组跳跃
#include<iostream>
using namespace std;

int jump(int A[],int n){
    if(n==1)
        return 0;

    int step=0;
    int i=0,j=0;
    int k,j2;

    while(j<n){
        step++;
        j2=j;

		for(k=i;k<=j;k++){
            j2=max(j2,k+A[k]);
            if(j2>=n-1)
                return step;
        }
        i=j+1;
        j=j2;
        if(j<i)
            return -1;
    }

    return step;
}


int main(){
    //int A[]={2,3,1,1,2,4,1,1,6,1,7};
	//int A[]={2,3,1,1,2};
	int A[]={2,3,1,4,1,1,1,1};
    int n=sizeof(A)/sizeof(A[0]);
    cout << jump(A,n) <<endl;
	system("pause");
    return 0;
}

#include<iostream>  
#include<queue>  
using namespace std;  
#define Max 10000  
int n,l,p;  
int A[Max],B[Max];  
int solve()  
{  
    //ans表示最后结果，即最小加油次数  
    //pos表示当前卡车位置  
    //tank表示油缸中油的数量   
    //que优先队列中存放之前能通过的各个加油站的最大加油量Bi   
    priority_queue<pair<int,int> > que;      
    int ans=0,pos=0,tank=p;  
    for(int i=0;i<n+1;i++)  
    {  
        int curDist=A[i]-pos;   //curDist表示到达下一个临时终点(加油站)的距离   
        while(curDist>tank)      //当前油不够到下一个终点   
        {  
            if(que.empty())  
            {  
                //cout<<"无法到达终点~"<<endl;  
                return -1;  
            }  
            pair<int,int> temp=que.top();  //priority_queue que默认排序是大顶堆；
            que.pop();  
            tank+=temp.first; 
			
            cout<<temp.first<<" ";     //不断加油,直到能到达下一个终点   
            cout<<temp.second+1<<" ";  
            ans++;  
        }  
          
        tank-=curDist;          //跑到下一个终点，消耗 curDist数量的油  
        pos=A[i];               //到达下一个加油站，取得该加油站的油，放在优先队列中，以便后面使用   
        que.push(make_pair(B[i],i));  
          
    }  
    cout<<endl;  
    return ans;  
}  
/*
int main()  
{  
    cin>>n>>l>>p;  
    for(int i=0;i<n;i++)  
    {  
        cin>>A[i]>>B[i];  
    }  
    A[n]=l;
    B[n]=0;
    cout<<"加油的站点的编号:";  
    cout<<solve();  
    system("pause");
    return 0;  
}
*/
