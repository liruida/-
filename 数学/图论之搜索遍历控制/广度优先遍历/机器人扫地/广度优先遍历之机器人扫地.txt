定义点point类，然后定义states状态类，表示当前点下的整个地图中的障碍物数量，目标坐标，机器人坐标的信息，根据状态类的变化进行移动，它周围的点是要接下来去移动到的位置，未被访问的点被放到队列openlist中，程序中是queue，在加入queue之前，要检测此节点是不是已经被访问过。

检测它有没有被访问过，如果目标地点只有一个，那么用有置为1类似那种状态数组的方式是可行的，但当目标地点不只是为一个时，以前被访问过的最短路径可能需要回退，重新访问它被访问过的节点，这个时候，有没有被访问的定义就变成了检测障碍物数量，目标坐标，机器人坐标三者是否完全一致的问题，如果三者同时相同，则意味着相同，记录在表示已经访问过的队列 closelist中；否则没有访问过，生成new states放入queue中，注意，目标坐标不仅一个，比较他们是否相同，如（0，0），（0，3）与（0，3），（0，0），程序一遍循环如（0，0）与（0，3），（0，0）比，其中若有一个为TRUE，则same置为TRUE。


例如：
输入
2 3
@_*
#*#

程序输出：
ESCNEC  14

方向示意图

   N
W     E
   S 
程序进入S后仍需回退到N，而（0，1）节点的_因为*数量的不同而是一个未被访问过的节点。
如果最终能到达*，则程序中必会有一个states到达所有*，此时程序结束，其它正在尝试的states也停止尝试，此states所找到的路径一定是最短的，因为它的结果探寻不具有跳跃性，在前者中间结果基础上进行的，其中其它未到达的states为它标记访问过的节点，避免其少走弯路做出了贡献。这时需要将到达的states的路径记录下来，所以在states属性中设置setPreviousState前端节点的方法，最后遍历此states链即可。遍历期间把每一个state的操作getOperation（）(由于直接输出的话是倒序)加入到output字符串之前,再输出output，便得到了正序输出。而14表示所有states进行过的尝试。这种算法是沿着树的宽度遍历树的节点，即图的广度，所以当深度depth很大的时候，需要遍历的节点就非常多。这个算法的空间复杂度(借助了好多state，程序生成了14个state)为O(B^M)，其中B是最大分支系数，本题中可以理解为机器上下移动的深度2，而M是树的最长路径长度，本题可以理解为长宽的最大值3；时间复杂度为O(N)即矩阵元素个数。










https://blog.csdn.net/u012907049/article/details/74980015

