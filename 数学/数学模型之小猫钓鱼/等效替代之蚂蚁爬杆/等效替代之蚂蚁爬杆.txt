题目：

 有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间。


解法：
  定义蚂蚁类，属性包括位置position，因为是一维空间所以用int即；爬行方向Direction，使用枚举类型了；boolean 类型 out判断是否爬出。方法即蚂蚁行为，包括行走 walk()，定义坐标轴右边为正方向，则右行position++；左行position--；判断调头方法；状态判断方法。

因为蚂蚁开始位置方向是不确定的，初始方向不是向左就是向右，可以用二进制表示，有五只， 2^5=32个组合，所以用0-31之间的整数的二进制刚好可以表示蚂蚁的初始方向。比如24的二进制为11000，分别与二进制数00001, 00010, 00100, 01000, 10000相与，结果为1的蚂蚁方向向右，可得第四、五只蚂蚁方向向右。反推，5只蚂蚁面对的方向如果为左，左，右，左，右，即00101，表示传入的i为（1+4）=5。

有了初始方向和初始位置, 就可以模拟比较，当蚂蚁在竿数大于0时，首先调用判断是否调头方法，数轴坐标0~27，定义flags[28],初始化为-1，循环五只蚂蚁，使：

 result = flags[ant.getPosition()];
	if(result == -1) {
				flags[ant.getPosition()] = (short)i; //如果还没有蚂蚁在这个位置，就记下这只蚂蚁的序号。
		} else { //如果已经有了，两只蚂蚁调头

如 4 6 10 16 22位置的蚂蚁循环过后，flags[]的flags[4]flags[6]flags[10]flags[16]flags[22]位置处全为-1；发现不需调头，else里的代码没执行；然后调用行走 walk()函数，每个蚂蚁调用此函数前先检测是否在杆，在则调用，五只调用完成后，计数器timer++；然后调用蚂蚁状态判断函数，检测position变化后的位置是否越界0~27，越界表示已经出去，修改蚂蚁状态，蚂蚁在竿总数--；蚂蚁在竿数大于0时继续循环上述过程，如5 5 11 17 23时， flags[5]=-1；flags[5]=5；第二个5循环到判断时result=flags[5]=5；result == -1不在成立，表示这两个蚂蚁需要调头，ant.shift();前头蚂蚁的坐标即这只的，通可过ants.get(result)获得，然后ants.get(result).shift();调头，shift()调头函数判断是不是右，是则改为左，否则表示是左改为右。
最终输出各方向下的time。




等效替代解法：
注意到“两只蚂蚁会同时调头朝反方向走”，也就是一秒钟两只蚂蚁完成调头和反方向爬行两个动作，可以理解为蚂蚁穿越了对方毫无影响地原方向前进（或者将两只蚂蚁互换来看待），那么：

最大时间就取决于两头的蚂蚁的方向：如果23厘米处的蚂蚁向原点爬行离开木杆，需用时23秒；如果3厘米处的蚂蚁向27厘米处爬行离开木杆，需用27-3=24秒，所以最大用时为24秒。

最小时间就取决于中间蚂蚁朝两头跑所用时间：如果处于小于等于11厘米处的蚂蚁向原点爬行离开木杆，需用时11秒；如果大于11厘米处的蚂蚁向27厘米处爬行离开木杆，需用27-17=10秒，所以都爬出最小用时为11秒。

所用算法：time=（L-pos）/1（速度）

L：竹竿长度
n：蚂蚁个数
pos[]：蚂蚁位置坐标

输入：                                                                               L=10                                                                                n=3                                                                                 
X={2,6,7}

输出：
min=4
max=8


#include<iostream>
#include<cstdlib>
#include<algorithm>
using namespace std;
int main()
{
	int L,n;
	double pos;
	cin>>L>>n;
	double minT=0,maxT=0;
	for(int i=0;i<n;i++)
	{
		cin>>pos;
		double temp=min(pos,L-pos);
		minT=max(minT,temp);
		
		temp=max(pos,L-pos);
		maxT=max(maxT,temp);
	}
	cout<<"min="<<minT<<endl;
	cout<<"max="<<maxT<<endl;
	return 0;
}




一般解法：https://blog.csdn.net/Radic_Feng/article/details/6844229

运用等效替代：
https://blog.csdn.net/qzq2514/article/details/54780882